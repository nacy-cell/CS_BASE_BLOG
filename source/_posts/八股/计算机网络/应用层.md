---
title: "应用层"  
date: 2025-10-30 00:00:00
categories: 
  - 八股
  - 计算机网络 
---

## 应用层有哪些协议

HTTP、FTP、HTTPS、SMTP、DNS协议

## HTTP报文有哪些部分

请求报文：

* 请求行:请求方法，请求目标，HTTP版本
* 请求头：请求的附加信息，如User-Agent,Content-Type,Host等
* 空行：请求头和请求体之间的分隔
* 请求体：可选，请求的数据

响应报文：

* 状态行：HTTP版本，状态码，状态信息
* 响应头：响应的附加信息，如Content-Type,Content-Length
* 空行：响应头和响应体之间的分隔
* 响应体：响应的数据，通常是HTML,JSON等内容

## HTTP常用状态码

* 1xx属于**提示**信息，是协议处理的一种中间状态，实际用到的较少
* 2xx表示**成功**处理了客户端请求
* 3xx表示客户端请求的资源发生了变动，客户端需要用新的URL发送请求获取资源，也就是**重定向**
* 4xx表示客户端发送的报文有问题，服务端无法处理，也就是错误码
* 5xx表示客户端请求正确，服务端内部出现问题，属于服务器错误码

常见的具体状态码：

* 200：请求成功
* 301：永久重定向
* 302：临时重定向
* 404：无法找到请求的资源
* 405：请求的方法不支持
* 500：服务器内部错误

## HTTP返回状态301,302分别是什么

* 301：表示永久重定向，请求的资源已经不存在了，需要改用新的URL再次访问
* 302:临时重定向，表示请求的资源还在，但临时需要用另一个URL访问

301和302都会在响应头的location字段指明要跳转的URL

## HTTP 502和504的区别是什么

* 502：bad gateway,作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应
* 504：gateway time-out,网关或代理服务器尝试执行请求时，未能及时从上有服务器接收到响应

## HTTP请求的类型有哪些

* GET:用于请求获取指定资源，通常用于获取指定数据
* POST:用于向服务器提供数据，通常用于提交表单数据或资源创建
* PUT:用于向服务器更新指定资源，通常用于更新已存在的资源
* DELETE:用于请求服务器删除指定资源
* HEAD:类似于GET请求，只返回头部信息，用于获取资源的元数据而不获取实际内容

## HTTP长连接是什么

HTTP采用的[请求-应答]模式，也就是客户端发送请求，服务器返回响应
由于HTTP是基于TCP协议实现的，客户端与服务器通信前，要先建立TCP连接，需要经历：建立TCP->请求资源->响应资源->释放连接(HTTP短连接)

HTTP的`keey-alive`实现了**HTTP长连接**，可以使用同一TCP连接来接受多个HTTP请求/应答，避免连接的建立和释放的开销

长连接的特点是：只要任意一端没有提出断开连接，则保持TCP连接状态

## HTTP默认端口是什么

http是80,https是443

## HTTP1.1怎么对请求拆包

HTTP 请求的结构是：请求行 → 头部字段 → 空行 → 请求体（可选）。

* 首先读取请求行，读取到空行表示请求头读取结束。
* 根据请求头的`content-length`,该字段指示了请求体的长度，服务器根据该长度正确接受和解析请求。

## HTTP断点重传是什么

HTTP协议中实现 “下载中断后无需重新下载整个文件，仅续传未完成部分”，主要用于优化大文件下载体验，减少带宽浪费。

* 客户端记录断点：当下载中断时，客户端会记录已成功下载的文件字节位置。
* 发起范围请求：再次下载时，客户端通过请求头的Range字段告知服务器续传起点
* 服务器部分响应：若服务器支持断点重传，会返回206状态码，同时通过Content-Range响应头明确本次返回的字节范围，并仅传输该范围的数据。
* 客户端拼接数据：客户端将新接收的部分数据与本地已下载的部分拼接，最终组成完整文件。

实现断点重传有两个关键前提：

* 一是服务器需开启对Range请求的支持（静态文件服务器通常默认支持，动态内容需额外配置）；
* 二是文件未被修改，客户端会通过Last-Modified或ETag验证文件完整性，若文件已变则需重新下载。

## HTTP为什么不安全

HTTP是明文传输，因此存在以下三个风险：

* 窃听风险：通信链路上可以获取通信内容
* 篡改风险：强制植入广告
* 冒充风险：冒充网站

HTTPS在TCP层添加了SSL/TLS协议，很好的解决了上述风险：

* 信息加密：对称加密 + 非对称加密结合
* 校验机制：无法篡改信息内容，篡改了就不能正常显示
* 身份证书：由权威机构背书，避免中间人伪装服务器

## HTTP与HTTPS区别

* HTTP是超文本传输协议，信息是明文传输，存在安全风险问题。HTTPS则解决HTTP不安全的特点，在TCP和HTTP层之间加入SSL/TLS协议，报文加密传输
* HTTP连接建立相对简单，TCP三次握手后即可进行HTTP报文传输。而HTTPS在三次握手后还要进行SSL/TLS握手，才能进行报文加密传输
* HTTP默认端口80,HTTPS443
* HTTPS需要向CA申请数字证书，来保证服务器的身份是可信的

## 讲一下HTTPS握手过程

### TLS第一次握手

客户端向服务器发送加密通信请求：

* 客户端支持的TLS版本
* 客户端产生的随机数，后续用于生成密钥
* 客户端支持的密码套件列表，如RSA

### TLS第二次握手

服务器接收到客户端请求后，向客户端发出响应：

* 确认TLS协议版本
* 服务器产生的随机数，后续用于生成密钥
* 确认的密码套件列表
* 服务器的数字证书

### TLS第三次握手

客户端收到服务器响应，首先通过浏览器或操作系统中的CA公钥，确认服务器数字证书的真实性

如果没有问题，客户端从数字证书中取出服务器的公钥，然后使用它加密报文(只加密随机数)，向服务器发送信息：

* 一个随机数
* 加密通信算法改变通知
* 客户端握手结束通知

客户端和服务器有了这三个随机数，接着就用双方协商的加密算法，各自生成本次通话的会话密钥

### TLS第四次握手

服务器收到客户端的第三个随机数后，计算出通信密钥

然后向客户端发送信息：

* 加密算法改变通知
* 服务器握手结束通知

接下来服务器与客户端进行加密通信

## HTTPS如何防止中间人攻击

* 加密：通过非对称加密协商对称加密密钥
* 身份校验：服务器向证书权威机构申请证书，证书包含服务器公钥等其他信息。客户端与服务器建立连接时，服务器会将证书发送给客户端。客户端校验证书的合法性，如果验证通过，客户端使用证书中的公钥加密通信数据发送给服务器，服务器用私钥解密

由于攻击者无法获取服务器的私钥，因此无法正确解密客户端发送的加密数据。客户端会验证服务器的证书，避免中间人伪装服务器

## HTTP1.1和2.0区别

* 头部压缩：如果同时发送多个请求，他们的头是一样的或相似的，HTTP2会消除重复部分。即HPACK算法：客户端和服务器同时维护一张头信息表，所有字段都会存入这张表，生成索引号，以后只需要发送索引号，这样就提高速度了
* 二进制格式：对计算机友好，提高传输效率
* 并发传输：提出Stream,多个Stream复用TCP连接，解决队头阻塞问题(HTTP3Quick协议基于UDP彻底解决队头阻塞)
* 服务器主动推送资源：服务器可以主动向客户端发送消息

## HTTP进行TCP连接后，什么情况会中断

* 当服务器或客户端执行close系统调用时会发送FIN报文，就会进行四次挥手
* 当发送方发送数据后，接收方超过一段时间没有响应ACK报文，发送方重传次数达到最大次数时就会断开TCP连接
* 当HTTP长时间没有进行请求和响应的时候，超过一定时间，就会释放

## HTTP,SOCKET和TCP的区别

* HTTP是用于传输超文本数据的应用层协议，用于在客户端和服务端之间传输和显示web数据
* SOCKET是是计算机网络的一种抽象，用于描述通信链路的一端，提供了底层的通信接口，可以实现不同计算机之间的数据交换
* TCP是一种面向连接的、可靠的传输层协议，负责在通信的两端之间建立可靠的数据传输连接

## DNS域名解析的工作流程

1. 客户端先查本地hosts 文件，若有域名-IP映射，直接返回，解析结束；否则进入下一步。
2. 客户端发出一个DNS请求，询问域名的ip,并发给本地DNS服务器
3. 本地DNS收到客户端的请求后，如果缓存里能找到，就直接返回，否则询问他的根域名服务器
4. 根DNS收到本地DNS请求后，返回顶级域名服务器地址
5. 本地DNS询问顶级域名服务器
6. 顶级域名服务器返回权威DNS服务器地址
7. 本地DNS询问权威DNS服务器
8. 权威DNS服务器查询后返回对应的ip地址
9. 本地DNS服务器将ip返回给客户端，同时存入自身缓存，客户端与目标建立连接

## DNS的默认端口是多少

53

## DNS底层是UDP还是TCP

DNS是基于UDP实现的，原因：

* 低延迟：UDP是一种无连接的协议，不需要在数据传输前建立连接，因此可以减少传输延迟
* 简单快速：UDP无连接管理和流量控制机制，传输效率更高
* 轻量级：UDP头部较小，占用较少的网络资源

DNS使用一些机制来提高可靠性，如超时重传，请求重试，缓存等，以确保数据传输的可靠性和正确性

## HTTT是不是无状态的

HTTP是无状态的，这意味着每个请求都是独立的，服务器不会在多个请求之间保留客户端的状态信息。
虽然HTTP本身是无状态的，但可以通过一些机制来实现状态保持，如cookie和session。通过在客户端存储会话信息和状态信息，服务器可以识别和跟踪特定用户的状态，以提供一定程度的状态保持功能

## Cookie是HTTP协议簇的一部分，那为什么说HTTP是无状态的

HTTP 协议在设计初衷上保持无状态特性，即每个请求都是相互独立的。使用 Cookie 只是在无状态协议下的一种补充机制，用于在客户端存储状态信息以实现状态保持。

## cookie和session的区别

* 存储位置：cookie存储在客户端。当浏览器向服务器发送请求时，会自动附带cookie中的数据。session的数据存储在服务器端。服务器为每个用户分配一个独立的sessionID,这个sessionID通过cookie或url重写的方式发送给客户端，客户端后续请求都会带上这个sessionID,服务器根据id查找对应的session数据
* 数据容量：单个cookie大小限制在4kb左右,而且大多数浏览器对每个域名的总cookie数量也有限制。由于session存储在服务器上，理论上不受数据大小限制
* 安全性：cookie相对不安全，因为数据存储在客户端，容易受到XSS攻击，不过可以通过设置HttpOnly属性阻止javaScript访问，但仍可能受到CSRF攻击。Session通常认为比cookie更安全，因为敏感数据存储在服务器端，但仍然需要防范session劫持
* 生命周期：cookie可以设置过期时间，过期后自动删除，也可以设置为会话cookie,即浏览器关闭后自动删除。session默认情况下，当用户关闭浏览器，session结束，服务器也可以设置session的超时时间
* 性能：cookie因为数据随每次请求发送到服务器，影响网络传输速度。session因为存储在服务器，每次请求查询服务器数据，这会增大服务器压力

## token,session,cookie的区别

* token:类似令牌，无状态，信息都被加密到token里，服务端收到token解密后就可以知道是哪个用户，需要开发者手动添加
* cookie:也类似令牌，当浏览器向服务器发送请求时，会自动附带cookie中的数据。
* session:存储在服务器，服务器为每个用户分配一个独立的sessionID,这个sessionID通过cookie或url重写的方式发送给客户端，客户端后续请求都会带上这个sessionID,服务器根据id查找对应的session数据

## 如果客户端禁用了cookie,session还能用吗

默认不能。大多数浏览器都是依靠cookie来传递会话id的
禁用cookie后，浏览器无法把会话id发给客户端，客户端也无法在后续请求中携带会话id,导致服务器无法识别用户会话

但是可以通过其他方法绕过：

* URL重写：每当服务器响应需要保存状态的请求时，将session id拼接到url中，服务器解析url来获取sessionId,这样的方法一是url不整洁，而是容易造成sessionID外泄
* 隐藏表单字段：在每个需要session信息的HTML表单中包含一个隐藏字段，用来存储sessionID,当表单提交时，session id随表单数据一起发送回服务器，服务器通过解析表单中的sessionId来获取用户状态。这种方法仅适用于通过表单提交的交互模式，不适合链接点击和ajax请求

## 如果把数据存到localStorage,和cookie有什么区别

* 存储容量：cookie大小一般几kb,localStorage可以存放几mb
* 数据发送：cookie在每次http请求都会自动发送到服务器，localStorage不会自动发送到服务器，他只在浏览器存储数据，因此适用于同一域名下不用页面的共享数据
* 生命周期：cookie可以设置过期时间，localStorage只能手动删除
* 安全性：cookie的安全性较低，因为每次http请求都会发给服务器，localStrage只存在浏览器，相对安全一些

## 什么数据应该存在cookie,什么数据存在localStorage

* cookie适用于在客户端和服务器传递信息，跨域访问和设置过期时间
* localStorage适用于在同一域名下的不同页面共享数据，存储大量数据和永久存储数据

## JWT令牌与传统方式有什么区别

* 无状态性：jwt是无状态令牌，不需要在服务器端存储会话信息，相反.jwt令牌包含了所有必要的信息，如用户身份，权限等
* 安全性：jwt使用密钥对令牌进行签名，确保令牌的真实性和完整性，只有持有正确的密钥才能对令牌验证和解析，有效防止了CSRF等攻击
* 跨域支持：jwt令牌可以在不用域之间传递，适用于跨域访问场景。通过在请求头中携带jwt令牌，实现无需cookie的跨域身份验证

## jwt令牌有哪些字段

jwt令牌由三部分组成：

* 头部
* 载荷
* 签名

头部和载荷都是json格式，使用base64编码进行序列化，签名部分是对头部、载荷和密钥进行签名

## jwt为什么能解决集群部署问题

在传统的基于session和cookie的身份验证方式中，session信息通常存储在服务器内存或数据库中，但在集群部署中，不同的服务器没有共享的会话信息，这导致用户在不同的服务器之间切换时需要重新登陆,或者引入额外的共享机制(如redis),增加了开销的复杂性

而jwt令牌在令牌中包含所需的身份验证和会话信息，使得服务器无需存储会话信息，解决了集群部署中身份验证和会话管理的问题。

由于jwt令牌是自包含的，服务器可以独立的对令牌进行验证，而不需要依赖其他服务器或共享存储，这使得集群中的每个服务器都可以独立处理请求，提高了系统的可伸缩性和可容错性

## jwt的缺点，令牌如果泄漏了，怎么解决

jwt一旦配发出去，在失效之前都是有效的，无法撤销
要解决这个问题，可以在业务层添加逻辑判断，如**黑名单机制**，使用内存数据库维护一个黑名单，将要失效的jwt加入黑名单即可

## 前端如何存储JWT

* 本地存储(Local Storage)
* * 优点：LocalStorage存储空间大，且不会随http请求发送到服务器，因此不会出现在http缓存或日志中
* * 缺点：存在 XSS（跨站脚本攻击）的风险，恶意脚本可以通过 JavaScript 访问到存储在 Local Storage 中的 JWT，从而盗取用户凭证
* Session Storage（会话存储）
* * 优点：与 Local Storage 类似，但仅限于当前浏览器窗口或标签页，当窗口关闭后数据会被清除，这在一定程度上减少了数据泄露的风险。
* * 缺点：用户体验可能受影响，因为刷新页面或在新标签页打开相同应用时需要重新认证。
* Cookie
* * 优点：可以设置 HttpOnly 标志来防止通过 JavaScript 访问，减少 XSS 攻击的风险；可以利用 Secure 标志确保仅通过 HTTPS 发送，增加安全性。
* * 缺点：大小限制较小，并且每次 HTTP 请求都会携带 Cookie，可能影响性能；设置不当可能会受到 CSRF（跨站请求伪造）攻击。

## 为什么有了HTTP还需要RPC

* 设计目标不同：HTTP是通用的应用层协议，强调跨平台、易扩展，但协议本身较冗余，更适合松散耦合场景，而RPC的核心是"让远程调用像本地函数一样简单"，目标是高效、低延迟、更侧重内部服务之间的通信
* 性能差异：HTTP常用JSON等文本格式，序列化慢、数据量大，且协议头冗余；RPC 多采用二进制协议，序列化效率高、数据紧凑，加上连接复用、多路复用等优化，更适合高频、大数据量的内部调用，能显著降低延迟。

## HTTP长连接和websocket有什么区别

* 全双工与半双工：TCP本身时全双工的，但HTTP1.1虽然基于TCP,但他是半双工的，对于大部分服务器主动推送数据到客户端的场景都不太友好,因此需要支持全双工的websocket
* 应用场景区别：HTTP长连接适合 “客户端需频繁向服务器请求数据” 的场景，通过复用连接减少 TCP 握手开销，但无法解决 “服务器主动推送” 需求。websocket适合 “双向实时通信” 场景,优势是低延迟、少开销，服务器可主动推送数据，无需客户端频繁轮询。

## nginx有哪些负载均衡算法

* 轮询
* ip哈希:根据ip的哈希值确定分配请求的服务器
* url哈希
* 最短响应时间:优先分配响应时间最短的服务器，适合服务器性能不均的场景
* 加权轮询：按照权重分配请求给服务器，权重越高的服务器分配的请求越多，适合服务器性能不均的场景

## nginx位于七层网络结构的哪一层

第七层应用层
