---
title: "第六章 包含多个段的程序"  
date: 2025-10-25 16:50:58
categories: 
  - 汇编语言
---

## 在代码段中使用数据

计算以下8个数据的和，结果保存在AX中：0123H，0456H，0789H，0ABCH，0DEFH，0FEDH，0CBAH，0987H

思路1：

```nasm
MOV   AX，0
ADD   AX，0123H
ADD   AX，0456H
ADD   AX，0789H
......
ADD   AX，0CBAH
ADD   AX，0987H
```

思路二:

思路2：

```nasm
MOV   AX, XXXXH
MOV   DS，AX
MOV   BX，0
MOV   CX，n
MOV   AX，0
S： 
ADD   AX，[BX]
ADD   BX，2
LOOP   S
```

定义数据伪指令：
DW—字型数据
DB—字节型数据
DD—双字数据
格式：
DW（DB）     数据1，数据2，数据3，……
如`num1 db 10h`or`db 10h`

`END`标号
标号—为程序中第一条要执行的指令的标号。
在编译中向编译器提供程序的入口地址和结束地址。

## 在代码段中使用栈

利用堆栈，编程将程序中定义的数据逆序存放。

```nasm
Assume cs:code
Code segment
Dw    0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
Dw     0,0,0,0,0,0,0,0
Start:      
    mov   ax,cs
    mov   ss,ax
    mov   sp,20h
    mov   bx,0
    mov   cx,8
S:     
    push  cs:[bx]
    add   bx,2
    loop   s
    mov   bx,0
    mov   cx,8
S0:
    pop   cs:[bx]
    add   bx,2
    loop   s0
    mov   ax,4c00h
    int   21h     
Code    ends
End start
```

## 将数据、代码、栈放入不同的段

1、定义多个段的方法：
同定义代码段一样，我们可以分别定义数据和栈段。
2、对段地址的引用：
每个段的名称对应着该段的段地址。
3、“代码段”、“数据段”、“栈段”完全是我们的安排：

* 数据、堆栈、代码在加载到内存时是在地址连续的一段内存空间上。
我们在源程序中为每个段起上名字只是为了便于阅读程序，并可以借用该名字（标号）所在的段地址。
* 我们在源程序中用伪指令`ASSUME  CS：CODE，DS：DATA，SS：STACK`进行段分配后，CPU并不能自动将段寄存器指向该段。程序刚加载到内存时，CS可根据END 标号来指向程序入口地址，而DS和ES的值为PSP的段地址；SS为DS+10H。所以在源程序中我们要通过指令初始化DS，ES和SS的值